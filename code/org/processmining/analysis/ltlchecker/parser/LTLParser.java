/* Generated By:JJTree&JavaCC: Do not edit this line. LTLParser.java */
package org.processmining.analysis.ltlchecker.parser;

import java.io.*;
import java.util.*;
import java.text.*;

/** * LTLParser is an parser for the LTL-language used in a LTL checking plugin * for the ProM framework. * * @version 0.4 * @author HT de Beer * @author PCW van den Brand */
public class LTLParser/*@bgen(jjtree)*/implements LTLParserTreeConstants, LTLParserConstants {/*@bgen(jjtree)*/
  protected JJTLTLParserState jjtree = new JJTLTLParserState();
/* Fields */

    /** attributes contains the by this parser recognized defined     * attributes.     */
    private ArrayList attributes;

    /** renamings contains the by this parser recognized defined renamings of     * already defined attributes.     */
    private ArrayList renamings;

    /** formulae contains the by this parser recognized defined formulae.     */
    private TreeMap formulae;

    /** Contains all formula names in the order they were defined in the LTL file */
    private ArrayList<String> orderedFormulaNames;

    /** Parameterized formula saves their parameter data.    */
    private TreeMap<String, List<FormulaParameter>> parameters;

    private String filename = null;

/* Methods */

        public static void main(String[] args) {
                if (args.length == 0) {
                        System.out.println("parseltl has one argument: the name"
                                        + " of the file to parse.");
                } else {
            boolean verbose = args.length == 2 && args[1].equals("-v");
                        parseFile(args[0], verbose);
                }
        }


    public static void dump(SimpleNode node, String prefix, StringBuffer result) {
        result.append(prefix + SimpleNode.typeNames[node.getType()] + " : " + node.toString(true) + "\u005cn");
        for (int i = 0; i < node.jjtGetNumChildren(); ++i) {
            SimpleNode n = (SimpleNode) node.jjtGetChild(i);
            if (n != null) {
                dump(n, prefix + " ", result);
            }
        }
    }

    public void deleteFormula(String name) {
        formulae.remove(name);
        parameters.remove(name);
        orderedFormulaNames.remove(name);
    }

        public void writeToFile(String filename) throws IOException {
                writeToFile(filename, null);
        }

        public void writeToFile(String filename, Set<String> exportFormulas) throws IOException {
                PrintWriter out = new PrintWriter(new FileWriter(filename));

                out.println("# Attributes");
                for (Object o : attributes) {
                        out.println(((Attribute) o).asParseableAttributeDefinition());
                }
                out.println();
                out.println("# Renamings");
                for (Object o : renamings) {
                        out.println(((Attribute) o).asParseableRenaming());
                }
                out.println();
                out.println("# Formulae");
                for (String name : orderedFormulaNames) {
                        SimpleNode formula = (SimpleNode) getFormula(name);

                        assert(formula.getType() == SimpleNode.SUBFORMULA || formula.getType() == SimpleNode.FORMULA);

                        boolean writeAsSubformula = (formula.getType() == SimpleNode.SUBFORMULA || (exportFormulas != null && !exportFormulas.contains(formula.getName())));
                        out.println(formula.asParseableString(getParameters(formula.getName()), writeAsSubformula ? SimpleNode.SUBFORMULA : SimpleNode.FORMULA));
                }
                out.close();
        }

        public void setDefaultValues(String formulaName, Map<String, String> defaults) {
                for (FormulaParameter param : getParameters(formulaName)) {
                        String paramName = param.getParam().getValue();
                        if (defaults.containsKey(paramName)) {
                                param.setDefaultValue(defaults.get(paramName));
                        }
                }
        }

        public static void parseFile(String filename) {
        parseFile(filename, false);
    }

    public void setFilename(String filename) {
            this.filename = filename;
    }

    public String getFilename() {
        return filename;
    }

        public static void parseFile(String filename, boolean verbose) {

                try {
                        LTLParser lp = new LTLParser(
                                                   new FileInputStream(filename));
                        lp.init();

                        lp.parse();

            if (verbose) {
                for (Object formula : lp.getVisibleFormulaNames()) {
                    SimpleNode node = lp.getFormula((String) formula);
                    StringBuffer s = new StringBuffer();

                    dump(node, " | ", s);
                    System.out.println(formula);
                    System.out.println(s);
                }
                System.out.println("=========================================================================");
                for (Object o : lp.attributes) {
                    System.out.println(o);
                }
                System.out.println("=========================================================================");
                for (Object o : lp.renamings) {
                    System.out.println(o);
                }
                System.out.println("=========================================================================");
            }
        } catch( ParseException pe ) {
            System.out.println(
                "Error occured during parsing:\u005cn\u005cn\u005ct" +
                pe.getMessage() );
        } catch( IOException e ) {
            System.out.println(
            "Error while reading " + filename + ". Check"
            + " the file(name) and try again.");
        } catch( Exception e ) {
            System.out.println("Unknown error: " + e.getMessage());
//	    e.printStackTrace();        };
    }

    /** Construct a new LTLParser with new empty sets, before parsing, no     * attributes, renamings or formulae are defined.     */
    public void init() {
        attributes  = new ArrayList();
        renamings   = new ArrayList();
        formulae    = new TreeMap();
        orderedFormulaNames = new ArrayList<String>();
        parameters  = new TreeMap<String, List<FormulaParameter>>();
    }

    /**      * Does id exists as attribute, renaming or formula?      *      * @param id The string denoting the identifier to check.     *     * @return True if id exists, else false.     */
    public boolean existsId( String id ) {
        return (
            existsAttribute( id ) ||
            existsRenaming( id ) ||
            existsFormula( id )
            );
    }

    /**      * Does id exists as attribute or a renaming?      *      * @param id The string denoting the identifier to check.     *     * @return True if id exists, else false.     */
    public boolean existsAttribute( String id ) {
        boolean exists = false;
        Iterator i = attributes.iterator();
        Attribute attr;

        while ( i.hasNext() && (! exists )) {
            attr = (Attribute) i.next();
            if ( attr.getValue().equals( id ) ) {
                exists = true;
            };
        };

        return ( exists || existsRenaming( id ) );
    }

    /**      * Does id exists as a renaming?      *      * @param id The string denoting the identifier to check.     *     * @return True if id exists, else false.     */
    public boolean existsRenaming( String id ) {
        boolean exists = false;
        Iterator i = renamings.iterator();
        Attribute attr;

        while ( i.hasNext() && (! exists )) {
            attr = (Attribute) i.next();
            if ( attr.getValue().equals( id ) ) {
                exists = true;
            };
        };

        return ( exists );
    }

    /**      * Does id exists as formula?      *      * @param id The string denoting the identifier to check.     *     * @return True if id exists, else false.     */
    public boolean existsFormula( String id ) {
        return formulae.containsKey( id );
    }

    /**     * Get the list with attributes.     *     * @param The list with attributes.     */
    public ArrayList getAttributes() {
        return this.attributes;
    }

    /**      * Get the attribute linked with id.      *      * @param id The string denoting the identifier to finf the attribute of.     * THis id is already checked to be an attributeId.     *     * @return The attribute of id.     */
    public Attribute getAttribute( String id ) {
        Iterator i;
        if ( existsRenaming( id ) ) {
            i = renamings.iterator();
        } else {
            i = attributes.iterator();
        };

        boolean exists = false;
        Attribute attr = null;
        // Is possible because there must be an attribue with name equals id,        // that is the contract of this method.
        while ( i.hasNext() && (! exists )) {
            attr = (Attribute) i.next();
            if ( attr.getValue().equals( id ) ) {
                exists = true;
            };
        };

        return attr;
    }

    /** Get the formula linked with id.     *      * @param id The id to get the formula for. Id is already checked to     * contain an formula.     *     * @return The formula of id.     */
    public SimpleNode getFormula( String id ) {
        return (SimpleNode) formulae.get( id );
    }

    /** Get the parameters linked with id.     *      * @param id The id to get the parameters for. Id is already checked to     * contain a formula, and hencefort a parameterlist, which may be empty.     *     * @return The parameterlist of id.     */
    public List<FormulaParameter> getParameters( String id ) {
                return parameters.get( id );
    }

    private ParseException parseError( Token t, String message ) {
    // Create a new parse exception by token t with message.        return  new ParseException("Parse error at '" + t.image + "' ( " + t.beginLine +
                ", " + t.beginColumn + " ) : " + message);
    }

    /**     * Get the names of the visible formulae, that is of all formula.     *     * @return A array of names of te defined formulae.     */
    public ArrayList getVisibleFormulaNames( ) {
        ArrayList results = new ArrayList();
        Iterator i = formulae.values().iterator();
        SimpleNode formula;

        while (i.hasNext()) {
            formula = (SimpleNode) i.next();
            if ( formula.getType() == SimpleNode.FORMULA ) {
                results.add( formula.getName( ) );
            };
        };

        return results;
    }

    static private String cutQuotes( Token t ) {
        String s = t.image;
        return s.substring( 1, s.length() - 1);
    }

    private Attribute newAttribute( String value, int kind, Attribute attr) {
        Attribute attribute = null;

        switch ( attr.getType() ) {

            case Attribute.NUMBER :
                attribute = new NumberAttribute( value, kind, attr ); break;

            case Attribute.DATE :
                attribute = new DateAttribute( value, kind, attr ); break;

            case Attribute.STRING :
                attribute = new StringAttribute( value, kind, attr ); break;

            case Attribute.SET :
                attribute = new SetAttribute( value, kind, attr ); break;

        };

        return attribute;
    }

/**  * The grammar of the LTL language is defined below as production rules * decorated with some context checking in java. */
  final public void parse() throws ParseException {
 /*@bgen(jjtree) parse */
  ASTparse jjtn000 = new ASTparse(JJTPARSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case KDATE:
        case KFORMULA:
        case KNUMBER:
        case KRENAME:
        case KSET:
        case KSTRING:
        case KSUBFORMULA:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case KDATE:
        case KNUMBER:
        case KSET:
        case KSTRING:
          attributeDefinition();
          break;
        case KRENAME:
          renaming();
          break;
        case KFORMULA:
        case KSUBFORMULA:
          formulaDefinition();
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(0);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void attributeDefinition() throws ParseException {
 /*@bgen(jjtree) attributeDefinition */
    ASTattributeDefinition jjtn000 = new ASTattributeDefinition(JJTATTRIBUTEDEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Attribute   attribute;
    Token       idToken;
    Token       datePatternToken;
    int         type = -1;
    int         scope = -1;
    String      name = "";
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KNUMBER:
      case KSET:
      case KSTRING:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case KNUMBER:
          jj_consume_token(KNUMBER);
                      type = Attribute.NUMBER;
          break;
        case KSET:
          jj_consume_token(KSET);
                      type = Attribute.SET;
          break;
        case KSTRING:
          jj_consume_token(KSTRING);
                      type = Attribute.STRING;
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        if (jj_2_1(2)) {
          idToken = jj_consume_token(PIID);
                                  scope = Attribute.PI;
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ATEID:
            idToken = jj_consume_token(ATEID);
                                  scope = Attribute.ATE;
            break;
          default:
            jj_la1[3] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        name = idToken.image;
        jj_consume_token(SEMICOLON);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if (! existsId( name )) {

            // Add a specialized attribute to the list of attributes.
            switch ( type ) {
                case Attribute.NUMBER: {
                    attribute = new NumberAttribute( name, scope, type, Attribute.ATTRIBUTE );
                    attributes.add( attribute );
                }; break;
                case Attribute.SET: {
                    attribute = new SetAttribute( name, scope, type, Attribute.ATTRIBUTE );
                    attributes.add( attribute );
                }; break;
                case Attribute.STRING: {
                    attribute = new StringAttribute( name, scope, type, Attribute.ATTRIBUTE );
                    attributes.add( attribute );
                }; break;
            };


        } else {
            {if (true) throw parseError( idToken, " Identifier is already defined.");}
        };
        break;
      case KDATE:
        jj_consume_token(KDATE);
              type = Attribute.DATE;
        if (jj_2_2(2)) {
          idToken = jj_consume_token(PIID);
                                  scope = Attribute.PI;
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ATEID:
            idToken = jj_consume_token(ATEID);
                                  scope = Attribute.ATE;
            break;
          default:
            jj_la1[4] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        name = idToken.image;
        jj_consume_token(ASSIGN);
        datePatternToken = jj_consume_token(STRING_LITERAL);
        jj_consume_token(SEMICOLON);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if (! existsId( name )) {

            attribute = new DateAttribute( name, scope, type, Attribute.ATTRIBUTE );
            attribute.setDateParser(
                    new SimpleDateFormat( cutQuotes( datePatternToken ) ) );
            attributes.add( attribute );

        } else {
            {if (true) throw parseError( idToken, " Identifier is already defined.");}
        };
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void renaming() throws ParseException {
 /*@bgen(jjtree) renaming */
    ASTrenaming jjtn000 = new ASTrenaming(JJTRENAMING);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token newIdToken, oldIdToken;
    String newName, oldName;
    int scope = -1;
    int type = -1;
    try {
      jj_consume_token(KRENAME);
      if (jj_2_3(2)) {
        oldIdToken = jj_consume_token(PIID);
                               oldName = oldIdToken.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ATEID:
          oldIdToken = jj_consume_token(ATEID);
                               oldName = oldIdToken.image;
          break;
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(KAS);
      newIdToken = jj_consume_token(ID);
                           newName = newIdToken.image;
      jj_consume_token(SEMICOLON);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if ( existsAttribute( oldName ) ) {
            // The attribute is already defined, so it can be renamed
            if ( ! existsId( newName ) ) {
                // The new does not already exists, so it is a good name.
                Attribute renaming = newAttribute( newName,
                        Attribute.ATTRIBUTE, getAttribute( oldName ) );
                renamings.add( renaming );

            } else {
                // The id already exists, so renaming is not possible.
                {if (true) throw parseError( newIdToken, " Identifier is already defined.");}
            };

        } else {
            // The attribute is not (already) defined, so it can not be
            // renamed.
           {if (true) throw parseError( oldIdToken, " Identifier is not a defined"
                            + "attribute.");}
        };
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public SimpleNode formulaDefinition() throws ParseException {
 /*@bgen(jjtree) formulaDefinition */
    ASTformulaDefinition jjtn000 = new ASTformulaDefinition(JJTFORMULADEFINITION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token formulaToken;
    List<FormulaParameter> params = new ArrayList<FormulaParameter>();
    ArrayList paramAttributes = new ArrayList();
    Token descriptionToken;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KFORMULA:
        jj_consume_token(KFORMULA);
                                jjtn000.setType( SimpleNode.FORMULA );
        break;
      case KSUBFORMULA:
        jj_consume_token(KSUBFORMULA);
                                jjtn000.setType( SimpleNode.SUBFORMULA );
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      formulaToken = jj_consume_token(ID);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        params = argList();
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
                parameters.put( formulaToken.image, params );
                for (FormulaParameter p : params) {
                        paramAttributes.add(p.getParam());
                }
      jj_consume_token(RPAREN);
      jj_consume_token(ASSIGN);
      descriptionToken = jj_consume_token(DESC_LITERAL);
      jjtn000.setDescription( cutQuotes( descriptionToken ) );
      props(paramAttributes, formulaToken.image);
      jj_consume_token(SEMICOLON);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if ( ! existsId( formulaToken.image )) {

            jjtn000.setName( formulaToken );
            formulae.put( formulaToken.image, jjtn000 );
            orderedFormulaNames.add(formulaToken.image);
        } else {
            // The name already exists, so give an error
            {if (true) throw parseError( formulaToken, " Identifier is already defined." );}
        };
        {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public List<FormulaParameter> argList() throws ParseException {
 /*@bgen(jjtree) argList */
    ASTargList jjtn000 = new ASTargList(JJTARGLIST);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);FormulaParameter argument;
    List<FormulaParameter> localVars = new ArrayList<FormulaParameter>();
    try {
      argument = arg(localVars);
                                  localVars.add( argument );
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        argument = arg(localVars);
                                      localVars.add( argument );
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return localVars;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public FormulaParameter arg(List<FormulaParameter> localVars) throws ParseException {
 /*@bgen(jjtree) arg */
    ASTarg jjtn000 = new ASTarg(JJTARG);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token attributeToken;
    Token paramToken;
    boolean alreadyInLocalVars = false;
    Attribute param = null, defaultAttr = null;
    String defaultValue = null;
    try {
      paramToken = jj_consume_token(ID);
                for (FormulaParameter p : localVars) {
                    if ( p.getParam().getValue().equals( paramToken.image ) ) {
                                alreadyInLocalVars = true;
                                break;
                    }
                }
        if ( existsId( paramToken.image ) || alreadyInLocalVars ) {
                // Id already exists in the context or on global scale.
                        {if (true) throw parseError( paramToken, " Identifier is already defined or used.");}
        }
      jj_consume_token(COLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        attributeToken = jj_consume_token(ID);
        break;
      case PIID:
        attributeToken = jj_consume_token(PIID);
        break;
      case ATEID:
        attributeToken = jj_consume_token(ATEID);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        if (!  existsAttribute( attributeToken.image ) ) {
                    {if (true) throw parseError( attributeToken,  " Identifier is not a defined"
                                        + " attribute or a renaming.");}
        }
                param = newAttribute( paramToken.image, Attribute.ATTRIBUTE,  getAttribute( attributeToken.image ));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        jj_consume_token(COLON);
        defaultAttr = literal(param);
                                               defaultValue = defaultAttr.asParseableLiteralValue();
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return new FormulaParameter(param, defaultValue);}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode props(ArrayList localVars, String formulaName) throws ParseException {
 /*@bgen(jjtree) Proposition */
  ASTProposition jjtn000 = new ASTProposition(JJTPROPOSITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PNOT:
      case LALWAYS:
      case LEVENTUALLY:
      case LNEXTTIME:
        unaryProp(localVars, formulaName);
        break;
      case LPAREN:
        binaryProp(localVars, formulaName);
        break;
      case KEXISTS:
      case KFORALL:
        quantification(localVars, formulaName);
        break;
      default:
        jj_la1[12] = jj_gen;
        if (jj_2_4(2)) {
          comparison(localVars);
        } else if (jj_2_5(2)) {
          formulaCall(localVars, formulaName);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        jjtn000.setType(SimpleNode.PROPOSITION);
        {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode unaryProp(ArrayList localVars, String formulaName) throws ParseException {
 /*@bgen(jjtree) UnaryProposition */
  ASTUnaryProposition jjtn000 = new ASTUnaryProposition(JJTUNARYPROPOSITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PNOT:
        jj_consume_token(PNOT);
                  jjtn000.setType( SimpleNode.NOT );
        break;
      case LALWAYS:
        jj_consume_token(LALWAYS);
                  jjtn000.setType( SimpleNode.ALWAYS );
        break;
      case LEVENTUALLY:
        jj_consume_token(LEVENTUALLY);
                  jjtn000.setType( SimpleNode.EVENTUALLY );
        break;
      case LNEXTTIME:
        jj_consume_token(LNEXTTIME);
                  jjtn000.setType( SimpleNode.NEXTTIME );
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(LPAREN);
      props(localVars, formulaName);
      jj_consume_token(RPAREN);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode binaryProp(ArrayList localVars, String formulaName) throws ParseException {
 /*@bgen(jjtree) BinaryProposition */
  ASTBinaryProposition jjtn000 = new ASTBinaryProposition(JJTBINARYPROPOSITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      props(localVars, formulaName);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PAND:
        jj_consume_token(PAND);
                  jjtn000.setType( SimpleNode.AND );
        break;
      case POR:
        jj_consume_token(POR);
                  jjtn000.setType( SimpleNode.OR );
        break;
      case PIMPLIES:
        jj_consume_token(PIMPLIES);
                  jjtn000.setType( SimpleNode.IMPLIES );
        break;
      case PBIIMPLIES:
        jj_consume_token(PBIIMPLIES);
                  jjtn000.setType( SimpleNode.BIIMPLIES );
        break;
      case LUNTIL:
        jj_consume_token(LUNTIL);
                  jjtn000.setType( SimpleNode.UNTIL );
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      props(localVars, formulaName);
      jj_consume_token(RPAREN);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode quantification(ArrayList localVars, String formulaName) throws ParseException {
 /*@bgen(jjtree) Quantification */
    ASTQuantification jjtn000 = new ASTQuantification(JJTQUANTIFICATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Attribute dummy;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KFORALL:
        jj_consume_token(KFORALL);
                      jjtn000.setType( SimpleNode.FORALL );
        break;
      case KEXISTS:
        jj_consume_token(KEXISTS);
                      jjtn000.setType( SimpleNode.EXISTS );
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(LBRACKET);
      dummy = dummy(localVars);
        localVars.add( dummy );
        jjtn000.setDummy( dummy );
      jj_consume_token(BAR);
      props(localVars, formulaName);
      jj_consume_token(RBRACKET);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Attribute dummy(ArrayList localVars) throws ParseException {
 /*@bgen(jjtree) DummyVar */
    ASTDummyVar jjtn000 = new ASTDummyVar(JJTDUMMYVAR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token attributeToken;
    Token idToken;
    Attribute dum;
    boolean existsAsLocalVar = false;
    Iterator i = localVars.iterator();
    try {
      idToken = jj_consume_token(ID);
        while ( i.hasNext() ) {
            // Check if there is a local variable with name == id
            dum = (Attribute) i.next();
            if ( dum.getValue().equals( idToken.image ) ) {
                existsAsLocalVar = true;
            };
        };
        if ( existsId( idToken.image ) || existsAsLocalVar ) {
            // Id exists as global definition or as local var
            {if (true) throw parseError( idToken,  " Identifier is already in use in the local" +
                    " context.");}
        };
      jj_consume_token(COLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        attributeToken = jj_consume_token(ID);
        break;
      case PIID:
        attributeToken = jj_consume_token(PIID);
        break;
      case ATEID:
        attributeToken = jj_consume_token(ATEID);
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if ( ! existsAttribute( attributeToken.image ) ) {
            {if (true) throw parseError( attributeToken, " Identifier is not a defined"
                                + " attribute or a renaming.");}
        } else if (
                ! (getAttribute( attributeToken.image ).getType() == Attribute.SET)
                ) {

                    // error, quantification must over sets
                {if (true) throw parseError( attributeToken, " Identifier is not a set." );}

        };

        // Attribute exists and is of tye set:
        {if (true) return newAttribute( idToken.image, Attribute.ATTRIBUTE,
                                    getAttribute( attributeToken.image ) );}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode comparison(ArrayList localVars) throws ParseException {
 /*@bgen(jjtree) Comparison */
    ASTComparison jjtn000 = new ASTComparison(JJTCOMPARISON);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Attribute attribute;
    Token tok;
    int type;
    TreeSet strings = new TreeSet();
    try {
      attribute = attributeId(localVars);
        type = attribute.getType();
        jjtn000.setAttribute( attribute );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GT:
      case LT:
      case EQ:
      case LE:
      case GE:
      case NE:
      case REQ:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQ:
          jj_consume_token(EQ);
                          jjtn000.setType( SimpleNode.EQUAL );
          break;
        case NE:
          jj_consume_token(NE);
                          jjtn000.setType( SimpleNode.NOTEQUAL );
          break;
        case LE:
          jj_consume_token(LE);
                          jjtn000.setType( SimpleNode.LESSOREQUAL );
          break;
        case GE:
          jj_consume_token(GE);
                          jjtn000.setType( SimpleNode.BIGGEROREQUAL );
          break;
        case LT:
          jj_consume_token(LT);
                          jjtn000.setType( SimpleNode.LESSER );
          break;
        case GT:
          jj_consume_token(GT);
                          jjtn000.setType( SimpleNode.BIGGER );
          break;
        case REQ:
          tok = jj_consume_token(REQ);
                    if ( type != Attribute.STRING) {
                        // this operator does not exists then
                        {if (true) throw parseError( tok,
                            " Identifier is not a string."
                        );}
                    } else {
                        jjtn000.setType( SimpleNode.REGEXPEQUAL );
                    };
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        expr(type, localVars, attribute);
        break;
      case KIN:
        tok = jj_consume_token(KIN);
                    if ( type != Attribute.SET) {
                        // this operator does not exists then
                        {if (true) throw parseError( tok,
                            " Identifier is not a set."
                        );}
                    } else {
                        jjtn000.setType( SimpleNode.IN );
                    };
        jj_consume_token(LBRACKET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
          strings = stringList();
          break;
        default:
          jj_la1[18] = jj_gen;
          ;
        }
          jjtn000.setStrings( strings );
        jj_consume_token(RBRACKET);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode formulaCall(ArrayList localVars, String formulaName) throws ParseException {
 /*@bgen(jjtree) FormulaCall */
    ASTFormulaCall jjtn000 = new ASTFormulaCall(JJTFORMULACALL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token formulaToken;
    ArrayList values = new ArrayList();
    try {
      formulaToken = jj_consume_token(ID);
        if (! existsFormula( formulaToken.image ) ) {
            {if (true) throw parseError( formulaToken, " Identifier is not a defined formula.");}
        } else if ( formulaName.equals( formulaToken.image ) ) {
            // Recursion is forbidden, so if the name of this call is to the
            // function in which is call is placed, it is wrong.
            {if (true) throw parseError( formulaToken, " Recursion of formulae is not" +
                                " allowed. If you want to apply" +
                                " staterecursion, use [] and _O." +
                                " ( See the manual for more details.)");}
        } else {
            jjtn000.setName( formulaToken.image );
        };
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case REAL_LITERAL:
      case STRING_LITERAL:
      case PIID:
      case ATEID:
      case ID:
      case LBRACKET:
        values = valList(formulaToken.image, localVars);
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        jjtn000.setType( SimpleNode.USEFORMULA );
                if ( values.size() !=  parameters.get( formulaToken.image ).size()) {
                        {if (true) throw parseError( formulaToken, " Defined number of"
                                + " parameters not equal to the number of arguments"
                                + " applied here.");}
        };
        jjtn000.setValues( values );
        {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList valList(String formula, ArrayList localVars) throws ParseException {
 /*@bgen(jjtree) Values */
    ASTValues jjtn000 = new ASTValues(JJTVALUES);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);List<FormulaParameter> paramsOfFormula = parameters.get( formula );
    int paramOrder = 0;
    Attribute param;
    Attribute value;
    ArrayList values = new ArrayList();
    try {
        if ( !( paramsOfFormula.size() <= 0 ) ) {
            param = paramsOfFormula.get( paramOrder ).getParam();
        } else {
            param = null;
        };
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PIID:
      case ATEID:
      case ID:
        value = valId(param, localVars);
        break;
      case INTEGER_LITERAL:
      case REAL_LITERAL:
      case STRING_LITERAL:
      case LBRACKET:
        value = literal(param);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        paramOrder++;
        values.add( value );
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[22] = jj_gen;
          break label_3;
        }
          param = paramsOfFormula.get( paramOrder ).getParam();
        jj_consume_token(COMMA);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PIID:
        case ATEID:
        case ID:
          value = valId(param, localVars);
          break;
        case INTEGER_LITERAL:
        case REAL_LITERAL:
        case STRING_LITERAL:
        case LBRACKET:
          value = literal(param);
          break;
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
            paramOrder++;
            values.add( value );
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return values;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public TreeSet stringList() throws ParseException {
 /*@bgen(jjtree) StringList */
    ASTStringList jjtn000 = new ASTStringList(JJTSTRINGLIST);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);TreeSet strings = new TreeSet();
    Token st;
    String s;
    try {
      st = jj_consume_token(STRING_LITERAL);
      strings.add( cutQuotes( st ) );
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[24] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        st = jj_consume_token(STRING_LITERAL);
          strings.add( cutQuotes( st ) );
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return strings;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public List<String> conceptSet() throws ParseException {
 /*@bgen(jjtree) conceptSet */
    ASTconceptSet jjtn000 = new ASTconceptSet(JJTCONCEPTSET);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);List<String> strings = new ArrayList<String>();
    Token st;
    try {
      st = jj_consume_token(URI);
                     strings.add( st.image.substring(1) );
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case URI:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_5;
        }
        st = jj_consume_token(URI);
                             strings.add( st.image.substring(1) );
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return strings;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Attribute attributeId(ArrayList localVars) throws ParseException {
 /*@bgen(jjtree) Attribute */
    ASTAttribute jjtn000 = new ASTAttribute(JJTATTRIBUTE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token id;
    Attribute result;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        id = jj_consume_token(ID);
        break;
      case PIID:
        id = jj_consume_token(PIID);
        break;
      case ATEID:
        id = jj_consume_token(ATEID);
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        Iterator i = localVars.iterator();
        boolean found = false;
        Attribute attr = null;

        while ( i.hasNext() && (! found )) {
            attr = (Attribute) i.next();
            if ( attr.getValue().equals( id.image ) ) {
                found = true;
            };
        };

        if ( (! existsAttribute( id.image )) && (! found )) {
            {if (true) throw parseError( id, " Identifier is not a defined attribute.");}
        };
        if ( found ) {
            result = attr;
        } else {
            result = getAttribute( id.image );
        };

        {if (true) return result;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Attribute valId(Attribute param, ArrayList localVars) throws ParseException {
 /*@bgen(jjtree) ValueAttribute */
    ASTValueAttribute jjtn000 = new ASTValueAttribute(JJTVALUEATTRIBUTE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token id;
    Attribute val = null;
    Iterator i = localVars.iterator();
    boolean found = false;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        id = jj_consume_token(ID);
        break;
      case PIID:
        id = jj_consume_token(PIID);
        break;
      case ATEID:
        id = jj_consume_token(ATEID);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        while ( ( i.hasNext() ) && ( ! found ) ) {
            val = (Attribute) i.next();
            if ( val.getValue().equals( id.image ) ) {
                found = true;
            };
        };
        if ( found && ( ! localVars.isEmpty()) ) {
            if ( ! ( val.getType() == param.getType() ) ) {
                {if (true) throw parseError( id,
                    " Identifier has not the right type.");}
            }
        } else if (! existsAttribute( id.image ) ) {
            {if (true) throw parseError( id, " Identifier is not a local parameter in this context.");}
        } else {
            // It is a `global' par
            val = getAttribute( id.image ) ;
        };

        {if (true) return val;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Attribute literal(Attribute param) throws ParseException {
 /*@bgen(jjtree) Literal */
    ASTLiteral jjtn000 = new ASTLiteral(JJTLITERAL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token tok;
    Attribute result = null;
    String attribute = param.getAttributeId();
    int type = getAttribute( attribute ).getType();
    SimpleDateFormat sdf = new SimpleDateFormat();
    List<String> uris = new ArrayList<String>(0);
    Date date;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
        tok = jj_consume_token(STRING_LITERAL);
            if ( type == Attribute.STRING ) {
                result = (StringAttribute) newAttribute(
                    cutQuotes( tok ),
                    Attribute.LITERAL,
                    param);
            } else if ( type == Attribute.DATE ) {
                try {
                    // check if date literal can be parsed as specified
                    sdf =  param.getDateParser();
                    date = sdf.parse( cutQuotes( tok ) );
                    result = (DateAttribute) newAttribute(
                        cutQuotes( tok ),
                        Attribute.LITERAL,
                        param);

                } catch( Exception pe ) {
                    {if (true) throw parseError( tok, " Unable to parse this as a date" +
                        " given definition '" + sdf.toPattern() +
                        "'."
                        );}
                };
            } else if ( type == Attribute.SET ) {
                result = (SetAttribute) newAttribute(
                    cutQuotes( tok ),
                    Attribute.LITERAL,
                    param);
            } else {
                {if (true) throw parseError( tok, " Type mismatch.");}
            };
        break;
      case INTEGER_LITERAL:
        tok = jj_consume_token(INTEGER_LITERAL);
            if ( ! ( type == Attribute.NUMBER ) ) {
                {if (true) throw parseError( tok, "Not expected an integer" );}
            };
            result = (NumberAttribute) newAttribute(
                tok.image,
                Attribute.LITERAL,
                param);
        break;
      case REAL_LITERAL:
        tok = jj_consume_token(REAL_LITERAL);
            if ( ! ( type == Attribute.NUMBER ) ) {
                {if (true) throw parseError( tok,  "Not expected a floating point number." );}
            }
            result = (NumberAttribute) newAttribute(
                tok.image,
                Attribute.LITERAL,
                param);
        break;
      case LBRACKET:
        tok = jj_consume_token(LBRACKET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case URI:
          uris = conceptSet();
          break;
        default:
          jj_la1[28] = jj_gen;
          ;
        }
        jj_consume_token(RBRACKET);
            if ( ! ( type == Attribute.SET ) ) {
                {if (true) throw parseError(tok,  "Not expected a concept set." );}
            }
                result = new ConceptSetAttribute(uris, Attribute.LITERAL, param);
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return result;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode expr(int type, ArrayList localVars, Attribute lefthandSideAttribute) throws ParseException {
 /*@bgen(jjtree) Expr */
    ASTExpr jjtn000 = new ASTExpr(JJTEXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    Attribute param = null;
    Attribute value;
    Iterator i = localVars.iterator();
    boolean paramExists = false;
    SimpleDateFormat sdf = new SimpleDateFormat();
    List<String> uris = new ArrayList<String>(0);
    Date date;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case REAL_LITERAL:
      case LPAREN:
      case MINUS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MINUS:
          // - Number
                  t = jj_consume_token(MINUS);
                  jjtn000.setType( SimpleNode.UNMINUS );
          expr(type, localVars, lefthandSideAttribute);
          break;
        case LPAREN:
          // ( Number op Number )
                  t = jj_consume_token(LPAREN);
          expr(type, localVars, lefthandSideAttribute);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PLUS:
            jj_consume_token(PLUS);
                  jjtn000.setType( SimpleNode.PLUS );
            break;
          case MINUS:
            jj_consume_token(MINUS);
                  jjtn000.setType( SimpleNode.MINUS );
            break;
          case STAR:
            jj_consume_token(STAR);
                  jjtn000.setType( SimpleNode.MULT );
            break;
          case SLASH:
            jj_consume_token(SLASH);
                  jjtn000.setType( SimpleNode.DIV );
            break;
          default:
            jj_la1[30] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          expr(type, localVars, lefthandSideAttribute);
          jj_consume_token(RPAREN);
          break;
        case INTEGER_LITERAL:
          // INT
                  t = jj_consume_token(INTEGER_LITERAL);
            jjtn000.setType( SimpleNode.INT );
            jjtn000.setName( t.image );
            jjtn000.setAttribute(
                (NumberAttribute) newAttribute(
                    t.image,
                    Attribute.LITERAL,
                    lefthandSideAttribute) );
          break;
        case REAL_LITERAL:
          // REAL
                  t = jj_consume_token(REAL_LITERAL);
            jjtn000.setType( SimpleNode.REAL );
            jjtn000.setName( t.image );
            jjtn000.setAttribute(
                (NumberAttribute) newAttribute(
                    t.image,
                    Attribute.LITERAL,
                    lefthandSideAttribute) );
          break;
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        // One of the above choises implies type == number.
        if (! (type == Attribute.NUMBER)) {
            {if (true) throw parseError(  t, " Expected a numerical value.");}
        };

    {if (true) return jjtn000;}
        break;
      case STRING_LITERAL:
        // String-like expression
            t = jj_consume_token(STRING_LITERAL);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if ( type == Attribute.STRING ) {
            jjtn000.setType( SimpleNode.STRING );
            jjtn000.setName( cutQuotes( t ) );
            jjtn000.setAttribute(
                (StringAttribute) newAttribute(
                    cutQuotes( t ),
                    Attribute.LITERAL,
                    lefthandSideAttribute) );
        } else if ( type == Attribute.DATE ) {
            try {
                // check if date literal can be parsed as specified
                sdf = lefthandSideAttribute.getDateParser();
                date = sdf.parse( cutQuotes( t ) );

                jjtn000.setType( SimpleNode.DATESTRING );
                jjtn000.setName( cutQuotes( t ) );
                jjtn000.setAttribute(
                    (DateAttribute) newAttribute(
                        cutQuotes( t ),
                        Attribute.LITERAL,
                        lefthandSideAttribute) );

            } catch( Exception pe ) {
                {if (true) throw parseError( t,  " Unable to parse this as a date" +
                        " given definition '" + sdf.toPattern() +
                        "'." );}
            };
        } else if ( type == Attribute.SET ) {
            jjtn000.setType( SimpleNode.SETSTRING );
            jjtn000.setName( cutQuotes( t ) );
            jjtn000.setAttribute(
                (SetAttribute) newAttribute(
                    cutQuotes( t ),
                    Attribute.LITERAL,
                    lefthandSideAttribute) );
        } else {
            {if (true) throw parseError(t, " Expected a string.");}
        };

        {if (true) return jjtn000;}
        break;
      case LBRACKET:
        t = jj_consume_token(LBRACKET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case URI:
          uris = conceptSet();
          break;
        default:
          jj_la1[32] = jj_gen;
          ;
        }
        jj_consume_token(RBRACKET);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if ( type == Attribute.SET ) {
            jjtn000.setType( SimpleNode.CONCEPTSET );
            jjtn000.setName( uris.toString() );
            jjtn000.setAttribute( new ConceptSetAttribute(uris, Attribute.LITERAL, lefthandSideAttribute) );
        } else {
            {if (true) throw parseError(t, "Expected a set attribute.");}
        };

        {if (true) return jjtn000;}
        break;
      case PIID:
      case ATEID:
      case ID:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          t = jj_consume_token(ID);
          break;
        case PIID:
          t = jj_consume_token(PIID);
          break;
        case ATEID:
          t = jj_consume_token(ATEID);
          break;
        default:
          jj_la1[33] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        while ( i.hasNext() && (! paramExists)) {
            param = (Attribute) i.next();
            if (param.getValue().equals(t.image)) {
                paramExists = true;
            };
        };

        if ( ! existsAttribute( t.image ) ) {
            // t is not a global attribute or renaming
            if ( ! paramExists ) {
                // t is not a local renaming
                {if (true) throw parseError( t, " Identifier is not defined.");}
            } else {
                // param exists, so param is not empty
                if ( !( param.getType() == type ) ) {
                    // Wrong types
                    {if (true) throw parseError( t, " Type mismatch." );}
                } else {
                    // Good types, so build this node
                    jjtn000.setName( t.image );
                    jjtn000.setType( SimpleNode.ATTRIBUTE );
                    jjtn000.setAttribute( param );
                };
            };
        } else {
            // t is a global attribute or renaming
            if ( ! ( getAttribute( t.image ).getType() == type ) ) {
                // Wrong types
                {if (true) throw parseError( t, " Type mismatch." );}
            } else {
                // Good types
                jjtn000.setName( t.image );
                jjtn000.setType( SimpleNode.ATTRIBUTE );
                jjtn000.setAttribute( getAttribute( t.image ) );
            };
        };

        {if (true) return jjtn000;}
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_3R_11() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(PIID)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(PIID)) return true;
    return false;
  }

  private boolean jj_3R_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_11()) {
    jj_scanpos = xsp;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) {
    jj_scanpos = xsp;
    if (jj_3R_15()) {
    jj_scanpos = xsp;
    if (jj_3R_16()) {
    jj_scanpos = xsp;
    if (jj_3R_17()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_2() {
    if (jj_scan_token(PIID)) return true;
    return false;
  }

  private boolean jj_3R_7() {
    if (jj_scan_token(ID)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_10() {
    if (jj_scan_token(KIN)) return true;
    return false;
  }

  private boolean jj_3R_8() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_17() {
    if (jj_scan_token(REQ)) return true;
    return false;
  }

  private boolean jj_3R_16() {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_7()) return true;
    return false;
  }

  private boolean jj_3R_15() {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  private boolean jj_3R_6() {
    if (jj_3R_8()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_9()) {
    jj_scanpos = xsp;
    if (jj_3R_10()) return true;
    }
    return false;
  }

  private boolean jj_3R_14() {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_6()) return true;
    return false;
  }

  private boolean jj_3R_13() {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  private boolean jj_3R_12() {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public LTLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[35];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x3d4800,0x3d4800,0x190000,0x10000000,0x10000000,0x190800,0x10000000,0x204000,0x20000000,0x0,0x38000000,0x0,0x3000,0x0,0x0,0x3000,0x38000000,0x0,0x2000000,0x8000,0x3ac00000,0x3ac00000,0x0,0x3ac00000,0x0,0x0,0x38000000,0x38000000,0x0,0x2c00000,0x0,0xc00000,0x0,0x38000000,0x3ac00000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x1000,0xc0010004,0xc0010000,0x3c000000,0x0,0x0,0x3e0c000,0x0,0x3e0c000,0x40,0x40,0x400,0x40,0x400,0x0,0x0,0x0,0x0,0x40,0x1e0000,0x80004,0x0,0x0,0x80044,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x4,0x0,0x0,0x0,0x4,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[5];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public LTLParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public LTLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new LTLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public LTLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new LTLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public LTLParser(LTLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(LTLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[67];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 35; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 67; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 5; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
